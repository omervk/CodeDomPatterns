using System;
using System.CodeDom;
using System.Collections;
using System.Runtime.Serialization;
using System.Security.Permissions;

using DotNetZen.CodeDom.Patterns.XmlComments;

namespace DotNetZen.CodeDom.Patterns
{
	/// <summary>
	/// Represents the declaration of a type to which patterns can be applied.
	/// </summary>
	[Serializable, CLSCompliant(true)]
	public class CodePatternTypeDeclaration : CodeTypeDeclaration
	{
		private bool automaticComments = true;

		/// <summary>
		/// Initializes a new instance of the CodePatternTypeDeclaration class.
		/// </summary>
		public CodePatternTypeDeclaration()
		{
		}

		/// <summary>
		/// Initializes a new instance of the CodePatternTypeDeclaration class.
		/// </summary>
		/// <param name="name">The name of the type.</param>
		public CodePatternTypeDeclaration(string name) : base(name)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CodePatternTypeDeclaration class.
		/// </summary>
		/// <param name="automaticComments">true if you wish for the members generated by the patterns to automatically have xml comments.</param>
		public CodePatternTypeDeclaration(bool automaticComments)
		{
			this.automaticComments = automaticComments;
		}

		/// <summary>
		/// Initializes a new instance of the CodePatternTypeDeclaration class.
		/// </summary>
		/// <param name="name">The name of the type.</param>
		/// <param name="automaticComments">true if you wish for the members generated by the patterns to automatically have xml comments.</param>
		public CodePatternTypeDeclaration(string name, bool automaticComments) : this(name)
		{
			this.automaticComments = automaticComments;
		}

		/// <summary>
		/// Gets the patterns currently applied to the type.
		/// </summary>
		/// <value>The patterns currently applied to the type.</value>
		public TypePatterns AppliedPatterns
		{
			get
			{
				return (this.disposableApplied ? TypePatterns.Disposable : TypePatterns.None) |
					(this.serializableApplied ? TypePatterns.Serializable : TypePatterns.None);
			}
		}

		#region Disposable Type Pattern
		private static readonly string DisposeMethodName = typeof(IDisposable).GetMethod("Dispose").Name;
		private static readonly string SuppressFinalizeMethodName = typeof(GC).GetMethod("SuppressFinalize").Name;
		private static readonly string IDisposableName = typeof(IDisposable).FullName;
		private const string DisposingParameterName = "disposing";

		private CodeMemberMethod disposeImplementation;
		private CodeMemberMethod disposeCore;
		private bool disposableApplied = false;

		/// <summary>
		/// Applies the implementation of the dispose pattern using the <see cref="IDisposable"/> interface.
		/// </summary>
		/// <remarks>Please note: A bug in the .net frameworks up to 2.0 does not allow for creation of finalizers (destructors),
		/// which means that the pattern is incomplete. Please vote on this issue:
		/// http://lab.msdn.microsoft.com/ProductFeedback/viewFeedback.aspx?feedbackId=FDBK48431 </remarks>
		/// <example>Output example:<code>
		///	public class MyType : System.IDisposable
		///	{
		///		/// &lt;summary&gt;
		///		/// Releases all resources used by the object.
		///		/// &lt;/summary&gt;
		///		public void Dispose()
		///		{
		///			this.Dispose(true);
		///			System.GC.SuppressFinalize(this);
		///		}
		///	
		///		/// &lt;summary&gt;
		///		/// Releases the unmanaged resources used by the object and optionally releases the managed resources.
		///		/// &lt;/summary&gt;
		///		/// &lt;param name="disposing"&gt;true to release both managed and unmanaged resources; false to release only unmanaged resources.&lt;/param&gt;
		///		/// &lt;remarks&gt;This method is called by the public &lt;see cref="Dispose()" /&gt; method and the Finalize method.
		///		/// &lt;see cref="Dispose" /&gt; invokes the protected &lt;see cref="Dispose(System.Boolean)" /&gt; method with the &lt;paramref name="disposing" /&gt; parameter set to true.
		///		/// Finalize invokes Dispose with &lt;paramref name="disposing" /&gt; set to false.
		///		/// When the &lt;paramref name="disposing" /&gt; parameter is true, this method releases all resources held by any managed objects that this object references.
		///		/// This method invokes the &lt;see cref="Dispose()" /&gt; method of each referenced object.
		///		/// Notes to Inheritors: This method can be called multiple times by other objects. When overriding it, be careful not to reference objects that have been previously disposed of in an earlier call.&lt;/remarks&gt;
		///		protected virtual void Dispose(bool disposing)
		///		{
		///			if ((disposing == true))
		///			{
		///				if ((this.myReferenceTypeField != null))
		///				{
		///					((System.IDisposable)(this.myReferenceTypeField)).Dispose();
		///				}
		///				((System.IDisposable)(this.myValueTypeField)).Dispose();
		///			}
		///		}
		///	}
		/// </code></example>
		/// <param name="disposeType">Whether this is the first time the type's hierarchy has implemented the pattern.</param>
		/// <param name="implementationType">The way the implement the <see cref="IDisposable"/> interface.</param>
		/// <param name="objectsToDispose">The objects to dispose, such as variables and fields.</param>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		public void ApplyDisposablePattern(DisposeImplementationType disposeType, InterfaceImplementationType implementationType, params CodeInstanceReferenceExpression[] objectsToDispose)
		{
			if (this.disposableApplied)
			{
				throw new InvalidOperationException("Can not apply pattern when it is already applied.");
			}

			if (objectsToDispose == null)
			{
				throw new ArgumentNullException("objectsToDispose");
			}
			
			this.disposeCore = new CodeMemberMethod();
			this.disposeCore.Name = DisposeMethodName;
			this.disposeCore.Attributes &= ~MemberAttributes.AccessMask & ~MemberAttributes.ScopeMask;
			this.disposeCore.Attributes |= MemberAttributes.Family | (implementationType == InterfaceImplementationType.Implicit ? MemberAttributes.Overloaded : 0);
			this.disposeCore.Parameters.Add(new CodeParameterDeclarationExpression(typeof(bool), DisposingParameterName));

			CodeConditionStatement ifDisposing = new CodeConditionStatement(new CodePatternUnaryOperatorExpression(CodePatternUnaryOperatorType.BooleanIsTrue, new CodeVariableReferenceExpression(DisposingParameterName)));

			foreach (CodeInstanceReferenceExpression disposableObject in objectsToDispose)
			{
				CodeExpressionStatement disposeCall = new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeCastExpression(typeof(IDisposable), disposableObject.Instance), DisposeMethodName));

				if (disposableObject.ObjectType == ResourceType.ValueType)
				{
					ifDisposing.TrueStatements.Add(disposeCall);
				}
				else
				{
					ifDisposing.TrueStatements.Add(
						new CodeConditionStatement(new CodePatternUnaryOperatorExpression(CodePatternUnaryOperatorType.BooleanNotNull, disposableObject.Instance),
						disposeCall));
				}
			}
			
			this.disposeCore.Statements.Add(ifDisposing);

			this.Members.Add(this.disposeCore);

			if (this.automaticComments)
			{
				this.disposeCore.Comments.AddRange(new SummaryStatements("Releases the unmanaged resources used by the object and optionally releases the managed resources."));
				this.disposeCore.Comments.AddRange(new ParameterStatements(DisposingParameterName, "true to release both managed and unmanaged resources; false to release only unmanaged resources."));
				this.disposeCore.Comments.AddRange(new RemarksStatements(
					"This method is called by the public " + new SeeExpression(DisposeMethodName + "()") + " method and the Finalize method." + Environment.NewLine + 
					new SeeExpression(DisposeMethodName) + " invokes the protected " + new SeeExpression(DisposeMethodName + "(" + typeof(bool).FullName + ")") + " method with the " + new ParameterReferenceExpression(DisposingParameterName) + " parameter set to true." + Environment.NewLine +
					"Finalize invokes Dispose with " + new ParameterReferenceExpression(DisposingParameterName) + " set to false." + Environment.NewLine +
					"When the " + new ParameterReferenceExpression(DisposingParameterName) + " parameter is true, this method releases all resources held by any managed objects that this object references." + Environment.NewLine + 
					"This method invokes the " + new SeeExpression(DisposeMethodName + "()") + " method of each referenced object." + Environment.NewLine +
					"Notes to Inheritors: This method can be called multiple times by other objects. When overriding it, be careful not to reference objects that have been previously disposed of in an earlier call."));
			}

			if (disposeType == DisposeImplementationType.New)
			{
				this.BaseTypes.Add(typeof(IDisposable));

				this.disposeImplementation = new CodeMemberMethod();
				this.disposeImplementation.Name = DisposeMethodName;

				if (implementationType == InterfaceImplementationType.Implicit)
				{
					this.disposeImplementation.Attributes &= ~MemberAttributes.AccessMask;
					this.disposeImplementation.Attributes |= MemberAttributes.Public | MemberAttributes.Overloaded;
				}
				else
				{
					this.disposeImplementation.PrivateImplementationType = CodeTypeReferenceStore.Get(typeof(IDisposable));
				}

				this.disposeImplementation.Statements.Add(new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), DisposeMethodName, new CodePrimitiveExpression(true))));
				this.disposeImplementation.Statements.Add(new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(GC)), SuppressFinalizeMethodName, new CodeThisReferenceExpression())));
            
				this.Members.Add(this.disposeImplementation);

				if (this.automaticComments)
				{
					this.disposeImplementation.Comments.AddRange(new SummaryStatements("Releases all resources used by the object."));
				}
			}
			else
			{
				this.disposeCore.Statements.Insert(0, new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeBaseReferenceExpression(), DisposeMethodName, 
					new CodeVariableReferenceExpression(DisposingParameterName))));
			}

			this.disposableApplied = true;
		}

		/// <summary>
		/// Applies the implementation of the dispose pattern using the <see cref="IDisposable"/> interface.
		/// </summary>
		/// <remarks>Implementation type is inferred to be <see cref="InterfaceImplementationType.Implicit"/>.
		/// Please see <see cref="ApplyDisposablePattern(DisposeImplementationType, InterfaceImplementationType, CodeInstanceReferenceExpression[])"/> for more.</remarks>
		/// <param name="objectsToDispose">The objects to dispose, such as variables and fields.</param>
		/// <param name="disposeType">Whether this is the first time the type's hierarchy has implemented the pattern.</param>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		public void ApplyDisposablePattern(DisposeImplementationType disposeType, params CodeInstanceReferenceExpression[] objectsToDispose)
		{
			this.ApplyDisposablePattern(disposeType, InterfaceImplementationType.Implicit, objectsToDispose);
		}

		/// <summary>
		/// Applies the implementation of the dispose pattern using the <see cref="IDisposable"/> interface.
		/// </summary>
		/// <remarks>Implementation type is inferred to be <see cref="DisposeImplementationType.New"/>.
		/// Please see <see cref="ApplyDisposablePattern(DisposeImplementationType, InterfaceImplementationType, CodeInstanceReferenceExpression[])"/> for more.</remarks>
		/// <param name="objectsToDispose">The objects to dispose, such as variables and fields.</param>
		/// <param name="implementationType">The way the implement the <see cref="IDisposable"/> interface.</param>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		public void ApplyDisposablePattern(InterfaceImplementationType implementationType, params CodeInstanceReferenceExpression[] objectsToDispose)
		{
			this.ApplyDisposablePattern(DisposeImplementationType.New, implementationType, objectsToDispose);
		}

		/// <summary>
		/// Applies the implementation of the dispose pattern using the <see cref="IDisposable"/> interface.
		/// </summary>
		/// <remarks>Implementation type is inferred to be <see cref="DisposeImplementationType.New"/> and <see cref="InterfaceImplementationType.Implicit"/>.
		/// Please see <see cref="ApplyDisposablePattern(DisposeImplementationType, InterfaceImplementationType, CodeInstanceReferenceExpression[])"/> for more.</remarks>
		/// <param name="objectsToDispose">The objects to dispose, such as variables and fields.</param>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		public void ApplyDisposablePattern(params CodeInstanceReferenceExpression[] objectsToDispose)
		{
			this.ApplyDisposablePattern(DisposeImplementationType.New, InterfaceImplementationType.Implicit, objectsToDispose);
		}

		/// <summary>
		/// Removes the implementation of the dispose pattern from the type.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is not applied when called.</exception>
		public void RemoveDisposablePattern()
		{
			if (!this.disposableApplied)
			{
				throw new InvalidOperationException("Can not remove pattern before it has been applied.");
			}

			foreach (CodeTypeReference reference in this.BaseTypes)
			{
				if (reference.BaseType == IDisposableName)
				{
					this.BaseTypes.Remove(reference);
					break;
				}
			}

			if (this.disposeImplementation != null)
			{
				this.Members.Remove(this.disposeImplementation);
				this.disposeImplementation = null;
			}

			this.Members.Remove(this.disposeCore);
			this.disposeCore = null;

			this.disposableApplied = false;
		}

		/// <summary>
		/// Gets the method implementing the <see cref="IDisposable"/> interface.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is not applied when called.</exception>
		/// <value>The method implementing the <see cref="IDisposable"/> interface.</value>
		protected CodeMemberMethod DisposeImplementation
		{
			get
			{
				if (!this.disposableApplied)
				{
					throw new InvalidOperationException("Could not access implementation of the dispose pattern when it is not yet applied.");
				}

				return this.disposeImplementation;
			}
		}

		/// <summary>
		/// Gets the method that actually disposes of objects.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is not applied when called.</exception>
		/// <value>The method that actually disposes of objects.</value>
		protected CodeMemberMethod DisposeCore
		{
			get
			{
				if (!this.disposableApplied)
				{
					throw new InvalidOperationException("Could not access implementation of the dispose pattern when it is not yet applied.");
				}

				return this.disposeCore;
			}
		}
		#endregion

		#region Serializable Type Pattern
		private const string InfoParameterName = "info";
		private const string ContextParameterName = "context";

		private static readonly string SerializableAttributeType = typeof(SerializableAttribute).FullName;
		private static readonly string NonSerializedAttribute = typeof(NonSerializedAttribute).FullName;
		private static readonly string ISerializableName = typeof(ISerializable).FullName;
		private static readonly string GetObjectDataMethodName = typeof(ISerializable).GetMethod("GetObjectData").Name;
		private static readonly string GetValueMethodName = typeof(SerializationInfo).GetMethod("GetValue").Name;
		private static readonly string AddValueMethodName = typeof(SerializationInfo).GetMethod("AddValue", new Type[] { typeof(string), typeof(object), typeof(Type) }).Name;

		private CodeConstructor serializableConstructor;
		private CodeMemberMethod getObjectData;
		private CodeAttributeDeclaration serializableAttribute;
		private bool serializableApplied = false;

		/// <summary>
		/// Applies the implementation of the serializable type pattern using the <see cref="ISerializable"/> interface.
		/// </summary>
		/// <param name="serializationType">The type of serialization to apply to the type. See <see cref="SerializationType"/> for more information.</param>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		/// <remarks>Please see <see cref="ApplySerializablePattern(SerializationType, CodeMemberField[])"/> for more.</remarks>
		public void ApplySerializablePattern(SerializationType serializationType)
		{
			this.ApplySerializablePattern(serializationType, new CodeMemberField[0]);
		}

		/// <summary>
		/// Applies the implementation of the serializable type pattern using the <see cref="ISerializable"/> interface.
		/// </summary>
		/// <param name="serializationType">The type of serialization to apply to the type. See <see cref="SerializationType"/> for more information.</param>
		/// <param name="fieldsToSerialize">The fields to serialize for the type.</param>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		/// <exception cref="ArgumentException">Thrown if a field passed is marked as static.</exception>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if a field specified does not exist on the type.</exception>
		/// <remarks>Please see <see cref="ApplySerializablePattern(SerializationType, CodeMemberField[])"/> for more.</remarks>
		public void ApplySerializablePattern(SerializationType serializationType, params string[] fieldsToSerialize)
		{
			if (fieldsToSerialize == null)
			{
				throw new ArgumentNullException("fieldsToSerialize");
			}

			CodeMemberField[] fields = new CodeMemberField[fieldsToSerialize.Length];

			// Match requested fields to their objects.
			foreach (CodeTypeMember member in this.Members)
			{
				if (member is CodeMemberField)
				{
					int index = 0;

					for (; index < fieldsToSerialize.Length; index++)
					{
						if (fieldsToSerialize[index] == member.Name)
						{
							fields[index] = ((CodeMemberField)(member));
							index = fieldsToSerialize.Length;
						}
					}
				}
			}

			// Make sure all fields are accounted for.
			for (int index = 0; index < fields.Length; index++)
			{
				if (fields[index] == null)
				{
					throw new ArgumentOutOfRangeException("fieldsToSerialize", fieldsToSerialize[index], "Can not serialize a field that is not a member of the current type.");
				}
			}

			this.ApplySerializablePattern(serializationType, fields);
		}

		/// <summary>
		/// Applies the implementation of the serializable type pattern using the <see cref="ISerializable"/> interface.
		/// </summary>
		/// <param name="serializationType">The type of serialization to apply to the type. See <see cref="SerializationType"/> for more information.</param>
		/// <param name="fieldsToSerialize">The <see cref="CodeMemberField"/> objects that represent the fields to serialize for the type.</param>
		/// <remarks><example>Output example:<code>
		/// [System.SerializableAttribute()]
		///	public class MyType : System.Runtime.Serialization.ISerializable
		///	{
		///		private int myField;
		///
		///		/// &lt;summary&gt;
		///		/// Initializes a new instance of the &lt;see cref="MyType" /&gt; class.
		///		/// &lt;/summary&gt;
		///		/// &lt;param name="info"&gt;The data needed to serialize or deserialize an object.&lt;/param&gt;
		///		/// &lt;param name="context"&gt;The source and destination of a given serialized stream.&lt;/param&gt;
		///		/// &lt;remarks&gt;This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.&lt;/remarks&gt;
		///		protected MyType(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
		///		{
		///			this.myField = ((int)(info.GetValue("myField", typeof(int))));
		///		}
		///
		///		/// &lt;summary&gt;
		///		/// Populates a &lt;see cref="System.Runtime.Serialization.SerializationInfo" /&gt; with the data needed to serialize the target object.
		///		/// &lt;/summary&gt;
		///		/// &lt;param name="info"&gt;The &lt;see cref="System.Runtime.Serialization.SerializationInfo" /&gt; to populate with data.&lt;/param&gt;
		///		/// &lt;param name="context"&gt;The destination (see &lt;see cref="System.Runtime.Serialization.StreamingContext" /&gt;) for this serialization.&lt;/param&gt;
		///		/// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when the &lt;paramref name="info" /&gt; parameter is a null reference (Nothing in Visual Basic).&lt;/exception&gt;
        ///		[System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter)]
		///		public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
		///		{
		///			if ((info == null))
		///			{
		///				throw new System.ArgumentNullException("info");
		///			}
		///			info.AddValue("myField", this.myField, typeof(int));
		///		}
		///	}
		///	</code></example></remarks>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is applied when called.</exception>
		/// <exception cref="ArgumentException">Thrown if a field passed is marked as static.</exception>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if a field specified does not exist on the type.</exception>
		public void ApplySerializablePattern(SerializationType serializationType, params CodeMemberField[] fieldsToSerialize)
		{
			if (this.serializableApplied)
			{
				throw new InvalidOperationException("Can not apply pattern when it is already applied.");
			}

			if (fieldsToSerialize == null)
			{
				throw new ArgumentNullException("fieldsToSerialize");
			}

			foreach (CodeMemberField field in fieldsToSerialize)
			{
				if (field == null)
				{
					throw new ArgumentNullException("fieldsToSerialize", "One or more of the fields in the array is null.");
				}

				if ((field.Attributes & MemberAttributes.Static) == MemberAttributes.Static)
				{
					throw new ArgumentException("The field " + field.Name + " is static and can not be used for serialization.");
				}
			}

			this.serializableAttribute = new CodeAttributeDeclaration(SerializableAttributeType);
			this.CustomAttributes.Add(this.serializableAttribute);

			if (serializationType == SerializationType.Selective)
			{
				// Selective serialization means that fields not in the fieldsToSerialize array don't get serialized.
				ArrayList list = new ArrayList(fieldsToSerialize);
				
				foreach (CodeTypeMember member in this.Members)
				{
					CodeMemberField field = member as CodeMemberField;

					if (field != null)
					{
						if (list.Contains(field))
						{
							list.Remove(field);
						}
						else
						{
							field.CustomAttributes.Add(new CodeAttributeDeclaration(NonSerializedAttribute));
						}
					}
				}

				if (list.Count > 0)
				{
					throw new ArgumentOutOfRangeException("fieldsToSerialize", list.ToArray(typeof(CodeMemberField)), "The fields specified can not be found in the type.");
				}
			}
			else if (serializationType == SerializationType.NewCustom ||
				serializationType == SerializationType.InheritedCustom)
			{
				// Do not re-implement the interface.
				if (serializationType == SerializationType.NewCustom)
				{
					this.BaseTypes.Add(typeof(ISerializable));
				}

				// Prepare the constructor for serialization.
				this.serializableConstructor = new CodeConstructor();
				this.serializableConstructor.Attributes &= ~MemberAttributes.AccessMask;
				this.serializableConstructor.Attributes |= MemberAttributes.Family;
				this.serializableConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(SerializationInfo), InfoParameterName));
				this.serializableConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(StreamingContext), ContextParameterName));

				if (serializationType == SerializationType.InheritedCustom)
				{
					this.serializableConstructor.BaseConstructorArgs.Add(new CodeVariableReferenceExpression(InfoParameterName));
					this.serializableConstructor.BaseConstructorArgs.Add(new CodeVariableReferenceExpression(ContextParameterName));
				}
				
				// Prepare GetObjectData for serialization.
				this.getObjectData = new CodeMemberMethod();
				this.getObjectData.Name = GetObjectDataMethodName;
				this.getObjectData.Attributes &= ~MemberAttributes.AccessMask & ~MemberAttributes.ScopeMask;
				this.getObjectData.Attributes |= MemberAttributes.Public | (serializationType == SerializationType.InheritedCustom ? MemberAttributes.Override : 0);
				this.getObjectData.Parameters.Add(new CodeParameterDeclarationExpression(typeof(SerializationInfo), InfoParameterName));
				this.getObjectData.Parameters.Add(new CodeParameterDeclarationExpression(typeof(StreamingContext), ContextParameterName));

                Permissions.Security securityPermission = new Permissions.Security();
                securityPermission.Flags = SecurityPermissionFlag.SerializationFormatter;

                this.getObjectData.CustomAttributes.Add(new CodePatternCasAttribute(SecurityAction.LinkDemand, securityPermission));

				if (serializationType == SerializationType.InheritedCustom)
				{
					this.getObjectData.Statements.Add(
						new CodeMethodInvokeExpression(
							new CodeBaseReferenceExpression(), GetObjectDataMethodName, 
							new CodeVariableReferenceExpression(InfoParameterName), new CodeVariableReferenceExpression(ContextParameterName)));
				}
				else
				{
					this.getObjectData.Statements.Add(new CodePatternArgumentAssertNotNullStatement(InfoParameterName));
				}

				foreach (CodeMemberField field in fieldsToSerialize)
				{
					if (!this.Members.Contains(field))
					{
						throw new ArgumentOutOfRangeException("fieldsToSerialize", field, "The field specified can not be found in the type.");
					}

					// Deserialization of field.
					this.serializableConstructor.Statements.Add(new CodeAssignStatement(
						new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name),
						new CodeCastExpression(field.Type, 
							new CodeMethodInvokeExpression(
								new CodeVariableReferenceExpression(InfoParameterName), GetValueMethodName,
								new CodePrimitiveExpression(field.Name),
								new CodeTypeOfExpression(field.Type)))));

					// Serialization of field.
					this.getObjectData.Statements.Add(
						new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression(InfoParameterName), AddValueMethodName,
							new CodePrimitiveExpression(field.Name),
							new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name),
							new CodeTypeOfExpression(field.Type)));
				}

				if (this.automaticComments)
				{
					this.serializableConstructor.Comments.AddRange(new CommentsForConstructor(this.Name,
						new ParameterStatements(InfoParameterName, "The data needed to serialize or deserialize an object."),
						new ParameterStatements(ContextParameterName, "The source and destination of a given serialized stream.")));
					this.serializableConstructor.Comments.AddRange(new RemarksStatements("This member supports the .NET Framework infrastructure and is not intended to be used directly from your code."));

					this.getObjectData.Comments.AddRange(new CommentsForMethod("Populates a " + new SeeExpression(typeof(SerializationInfo)) + " with the data needed to serialize the target object.",
						new ParameterStatements(InfoParameterName, "The " + new SeeExpression(typeof(SerializationInfo)) + " to populate with data."),
						new ParameterStatements(ContextParameterName, "The destination (see " + new SeeExpression(typeof(StreamingContext)) + ") for this serialization.")));
					this.getObjectData.Comments.AddRange(new ExceptionStatements(typeof(ArgumentNullException), "Thrown when the " + new ParameterReferenceExpression(InfoParameterName) + " parameter is a null reference (Nothing in Visual Basic)."));
				}
				
				this.Members.Add(this.serializableConstructor);
				this.Members.Add(this.getObjectData);
			}

			this.serializableApplied = true;
		}
		
		/// <summary>
		/// Removes the implementation of the serialization pattern from the type.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is not applied when called.</exception>
		public void RemoveSerializablePattern()
		{
			if (!this.serializableApplied)
			{
				throw new InvalidOperationException("Can not remove pattern before it has been applied.");
			}

			// Remove ISerializable implementation.
			foreach (CodeTypeReference reference in this.BaseTypes)
			{
				if (reference.BaseType == ISerializableName)
				{
					this.BaseTypes.Remove(reference);
					break;
				}
			}

			// Remove NonSerializedAttributes from fields.
			foreach (CodeTypeMember member in this.Members)
			{
				if (member is CodeMemberField)
				{
					foreach (CodeAttributeDeclaration attribute in member.CustomAttributes)
					{
						if (attribute.Name == NonSerializedAttribute)
						{
							member.CustomAttributes.Remove(attribute);
							break;
						}
					}
				}
			}

			this.CustomAttributes.Remove(this.serializableAttribute);

			if (this.serializableConstructor != null)
			{
				this.Members.Remove(this.serializableConstructor);
				this.serializableConstructor = null;
			}

			if (this.getObjectData != null)
			{
				this.Members.Remove(this.getObjectData);
				this.getObjectData = null;
			}

			this.serializableApplied = false;
		}
		
		/// <summary>
		/// Gets the deserialization constructor.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is not applied when called.</exception>
		/// <value>The deserialization constructor.</value>
		protected CodeMemberMethod SerializableConstructor
		{
			get
			{
				if (!this.serializableApplied)
				{
					throw new InvalidOperationException("Could not access implementation of the serializable pattern when it is not yet applied.");
				}

				return this.serializableConstructor;
			}
		}

		/// <summary>
		/// Gets the serialization <see cref="ISerializable.GetObjectData"/> method.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown if the pattern is not applied when called.</exception>
		/// <value>The serialization <see cref="ISerializable.GetObjectData"/> method.</value>
		protected CodeMemberMethod GetSerializableObjectData
		{
			get
			{
				if (!this.serializableApplied)
				{
					throw new InvalidOperationException("Could not access implementation of the serializable pattern when it is not yet applied.");
				}

				return this.getObjectData;
			}
		}
		#endregion
	}
}